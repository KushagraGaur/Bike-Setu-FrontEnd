/**
 * @popperjs/core v2.10.2 - MIT License
 */
/**
 * @popperjs/core v2.10.2 - MIT License
 */

"use strict";

(function (global, factory) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        factory(exports);
    } else if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
    } else {
        factory((global = typeof globalThis !== "undefined" ? globalThis : global || self).Popper = {});
    }
})(this, function (exports) {
    function getRect(element) {
        const rect = element.getBoundingClientRect();
        return {
            width: rect.width / 1,
            height: rect.height / 1,
            top: rect.top / 1,
            right: rect.right / 1,
            bottom: rect.bottom / 1,
            left: rect.left / 1,
            x: rect.left / 1,
            y: rect.top / 1
        };
    }

    function getWindow(element) {
        if (!element) {
            return window;
        }
        return "[object Window]" !== element.toString()
            ? (element = element.ownerDocument) && element.defaultView || window
            : element;
    }

    function getScroll(element) {
        const win = getWindow(element);
        return {
            scrollLeft: win.pageXOffset,
            scrollTop: win.pageYOffset
        };
    }

    function isElement(element) {
        return element instanceof getWindow(element).Element || element instanceof Element;
    }

    function isHTMLElement(element) {
        return element instanceof getWindow(element).HTMLElement || element instanceof HTMLElement;
    }

    function isShadowRoot(element) {
        return "undefined" !== typeof ShadowRoot && (element instanceof getWindow(element).ShadowRoot || element instanceof ShadowRoot);
    }

    function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null;
    }

    function getDocumentElement(element) {
        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
    }

    function getScrollBarX(element) {
        return getRect(getDocumentElement(element)).left + getScroll(element).scrollLeft;
    }

    function getComputedStyle(element) {
        return getWindow(element).getComputedStyle(element);
    }

    function isScrollElement(element) {
        const style = getComputedStyle(element);
        return /auto|scroll|overlay|hidden/.test(style.overflow + style.overflowY + style.overflowX);
    }

    function getLayoutRect(element) {
        const rect = getRect(element);
        return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: element.offsetWidth,
            height: element.offsetHeight
        };
    }

    function getOffsetParent(element) {
        const win = getWindow(element);
        let offsetParent = element.offsetParent;
        while (offsetParent && ["html", "body"].indexOf(getNodeName(offsetParent)) >= 0 && getComputedStyle(offsetParent).position === "static") {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || win;
    }

    function getClippingRect(element, boundary, rootBoundary) {
        if ("viewport" === boundary) {
            const win = getWindow(element);
            const docElem = getDocumentElement(element);
            const visualViewport = win.visualViewport;
            const width = docElem.clientWidth;
            const height = docElem.clientHeight;
            let x = 0;
            let y = 0;
            if (visualViewport) {
                x = visualViewport.offsetLeft;
                y = visualViewport.offsetTop;
            }
            return {
                width,
                height,
                x,
                y
            };
        } else {
            const elementRect = getLayoutRect(element);
            return {
                ...elementRect,
                top: elementRect.top + element.clientTop,
                left: elementRect.left + element.clientLeft
            };
        }
    }

    function computeOffsets({ reference, element, placement }) {
        const basePlacement = placement.split("-")[0];
        const variation = placement.split("-")[1];
        const isHorizontal = ["left", "right"].indexOf(basePlacement) >= 0;
        const mainAxis = isHorizontal ? "x" : "y";
        const altAxis = isHorizontal ? "y" : "x";

        let offsets = {
            x: reference.x + reference.width / 2 - element.width / 2,
            y: reference.y + reference.height / 2 - element.height / 2
        };

        switch (basePlacement) {
            case "top":
                offsets.y = reference.y - element.height;
                break;
            case "bottom":
                offsets.y = reference.y + reference.height;
                break;
            case "right":
                offsets.x = reference.x + reference.width;
                break;
            case "left":
                offsets.x = reference.x - element.width;
                break;
        }

        if (variation) {
            const isStart = variation === "start";
            const size = isHorizontal ? "width" : "height";
            offsets[mainAxis] = isStart ? offsets[mainAxis] - reference[size] / 2 + element[size] / 2 : offsets[mainAxis] + reference[size] / 2 - element[size] / 2;
        }

        return offsets;
    }

    function detectOverflow(state, options) {
        const {
            placement,
            boundary,
            rootBoundary,
            padding,
            elementContext,
            altBoundary
        } = options;
        const paddingObject = typeof padding !== "number" ? padding : {
            top: padding,
            right: padding,
            bottom: padding,
            left: padding
        };
        const altContext = altBoundary ? "reference" : elementContext;

        const element = state.elements[altContext];
        const clippingRect = getClippingRect(element, boundary, rootBoundary);
        const offsets = computeOffsets({
            reference: state.rects.reference,
            element: state.rects.popper,
            placement
        });

        const popperRect = {
            ...state.rects.popper,
            x: offsets.x,
            y: offsets.y
        };

        return {
            top: clippingRect.top - popperRect.top + paddingObject.top,
            right: popperRect.right - clippingRect.right + paddingObject.right,
            bottom: popperRect.bottom - clippingRect.bottom + paddingObject.bottom,
            left: clippingRect.left - popperRect.left + paddingObject.left
        };
    }

    function popperGenerator(generatorOptions = {}) {
        const {
            defaultModifiers = [],
            defaultOptions = {}
        } = generatorOptions;

        return function createPopper(reference, popper, options = defaultOptions) {
            const state = {
                placement: options.placement || "bottom",
                orderedModifiers: [],
                options: {
                    ...defaultOptions,
                    ...options
                },
                modifiersData: {},
                elements: {
                    reference,
                    popper
                },
                styles: {},
                attributes: {}
            };

            return {
                state,
                setOptions(newOptions) {
                    state.options = {
                        ...state.options,
                        ...newOptions
                    };
                    return this;
                },
                forceUpdate() {
                    const { reference, popper } = state.elements;
                    state.rects = {
                        reference: getLayoutRect(reference),
                        popper: getLayoutRect(popper)
                    };
                    state.orderedModifiers.forEach(modifier => {
                        if (modifier.enabled) {
                            modifier.fn({
                                state,
                                name: modifier.name,
                                instance: this
                            });
                        }
                    });
                },
                update() {
                    return new Promise(resolve => {
                        this.forceUpdate();
                        resolve(state);
                    });
                },
                destroy() {
                    state.elements.reference = null;
                    state.elements.popper = null;
                }
            };
        };
    }

    const createPopper = popperGenerator();

    exports.createPopper = createPopper;
});

//# sourceMappingURL=popper.min.js.map
